# 语言特性

我们的`C4m`之于`C`类似于`Chisel`之于`Verilog`：将`C4m`作为
一种DSL内嵌在Haskell中。这样既可以在编译期享受到Haskell带来的
类型系统和其他的抽象特性，也可以生成（相对于我们自己去发明的编译
器而言）高效的二进制代码。

这样的梦想非常美好，但事实证明这么做会产生相当的麻烦和冗余。尽管
如此，我们依然将我们的做法忠实地阐述如下。

## 基本类型

`C4m`包括如下基本类型：
- 平台无关类型：`Int8`, `UInt8`, `Int16`, `UInt16`, `Int32`, `UInt32`, `Int64`, `UInt64`
- 平台相关类型：`Word` (视平台不同可能为 `Int32` 或 `UInt32`), `UWord`, `Size`, `USize`
- 函数类型：`Fn a b`，其中`a`为返回值，`b`为参数列表。
- 指针：`Ptr a`，即为指向`a`类型的指针
- 数组：`Arr a`，即为`a`类型元素组成的数组。

在`C4m`中，只有数组代表了内存布局的。换言之，指针也只能指向数组内的元素。

## 程序结构

我们支持了这些操作：
- 引入立即值。
- 一元或二元操作，有如下这些：
    - 一元操作符，包括一般的`Integer`的位反转，还有`Boolean`的取反。
    - 算术操作符，有`Add`，`Sub`，`Mul`，`Div`，`Mod`。
    - 位操作，与或异或。
    - 移位操作。
    - 比较操作，还有逻辑的与或异或。
- 类型转换。`C4m`仅支持显式的类型转换。
- 定义函数。与`C`相同地，因为`C4m`的函数不是第一类公民，所以需要支持提前的函数声明，我们提供了`Invoke`。
- 引用和解引用。

为了在没有副作用的语言（`Haskell`）中引入副作用（我们的`C4m`），我们使用了下面的
设计思路：

我们将语言特性封装进`Monad`中。最基础的特性，如前所述的，我们放在`C Monad`中。
进一步地，其他的特性，如`UEFI`，我们放在了`UEFI Monad`中。通过组合各种各样的
`Monad`我们可以获得想要的语言特性。

## 一些反思

尽管这个想法很美好，我们的一大麻烦就自与此。比如：
```
    liftC $ foreverLoop $ lift $ liftC $ Typerkernel.Std.X86_64.break
```

这绝对不是我们的初衷，但这居然成了我们的唯一解决方案，不得不说这是荒谬的。
诚然，`Haskell`的类型系统在开始的时候给了我们不少帮助，但当我们现在回过头看的时候，
DSL可能不是这个问题的好选择。过去的经验告诉我们，比起正确但繁琐，我们可能更需要
不那么正确但简洁。